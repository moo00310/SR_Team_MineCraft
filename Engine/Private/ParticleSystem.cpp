#include "ParticleSystem.h"

CParticleSystem::CParticleSystem(LPDIRECT3DDEVICE9 pGraphic_Device) : CGameObject(pGraphic_Device)
{
}

CParticleSystem::CParticleSystem(const CParticleSystem& Prototype) : 
	CGameObject(Prototype)		
{
	Safe_AddRef(m_pVB);		
	Safe_AddRef(m_pParticleTexture);
}

HRESULT CParticleSystem::Initialize(void* pArg)
{
 	if (FAILED(Create_VertexBuffer()))
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT CParticleSystem::Initialize_Prototype()
{
	return S_OK;
}

void CParticleSystem::Update(_float fTimeDelta)
{
	for (auto& data : m_ListParticleAttribute)
	{
		if (data.IsAlive == true && data.IsTime == true)
		{
			data.fCurrentTime += fTimeDelta;
		}

		if (data.IsAlive == true && data.fCurrentTime >= data.fEndTime && data.IsTime == true)
		{
			data.IsAlive = false;
		}

		data.vPosition += data.vVelocity * fTimeDelta;		
	}
}

HRESULT CParticleSystem::Render()
{
	if (m_ListParticleAttribute.size() <= 0)
	{
		return S_OK;
	}

	if (FAILED(PrevRender()))
	{
		return E_FAIL;
	}

	Bind_Buffers();

	// 파티클 버텍스 버퍼.
	VTXPARTICLE* p = 0;

	// 현재 세그먼트의 버텍스 단계.
	_uint currentVertexIndex = 0;	

	// 오프셋 초기화.
	dwVpOffset = 0;

	// dwVpOffset * sizeof(VTXPARTICLE)에서 dwVpSBatchSize * sizeof(PARTICLE) 크기만큼 할당.
	m_pVB->Lock(dwVpOffset * sizeof(VTXPARTICLE), dwVpSBatchSize * sizeof(VTXPARTICLE), (void**)&p, D3DLOCK_NOOVERWRITE);

	// 파티클 인스턴싱 로직.
	for (auto& data : m_ListParticleAttribute)
	{
		// 생존한 파티클인지 확인.
		if (data.IsAlive == false)
		{
			continue;
		}

		p->Position = data.vPosition;
		p->Color = data.vColor;

		// 다음 버텍스로 증가.
		p++;

		// 현재 세그먼트의 단계 증가.
		currentVertexIndex++;

		// 현재 세그먼트 단계가 다 채워졌을 경우 그린다.
		if (currentVertexIndex == dwVpSBatchSize)
		{
			// 잠금 해제.
			m_pVB->Unlock();

			// 지정 범위 점을 그린다.			
			m_pGraphic_Device->DrawPrimitive(
				D3DPT_POINTLIST,
				dwVpOffset,
				dwVpSBatchSize);			

			// 오프셋 추가.
			dwVpOffset += dwVpSBatchSize;

			// 다음 세그먼트 그리기 위한 락.
			m_pVB->Lock(dwVpOffset * sizeof(VTXPARTICLE), dwVpSBatchSize * sizeof(VTXPARTICLE), (void**)&p, D3DLOCK_NOOVERWRITE);

			// 현재 세그먼트의 단계 초기화.
			currentVertexIndex = 0;
		}		
	}	

	if (FAILED(EndRender()))
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT CParticleSystem::Bind_Buffers()
{
	m_pGraphic_Device->SetStreamSource(0, m_pVB, 0, sizeof(VTXPARTICLE));

	/* 장치가 알아서 내 정점을 이용하여 특정 연산을 수행할 수 있도록 */
	/* 내 정점의 정보를 알려준다. */
	m_pGraphic_Device->SetFVF(m_iFVF);

	return S_OK;
}

HRESULT CParticleSystem::PrevRender()
{
	// 포인트 스프라이트 활성화.
	m_pGraphic_Device->SetRenderState(D3DRS_POINTSPRITEENABLE, true);
	
	// 포인트 스프라이트 크기를 뷰 스페이스 단위로 해석.
	m_pGraphic_Device->SetRenderState(D3DRS_POINTSCALEENABLE, true);

	// 포인트 스프라이트 크기.
	m_pGraphic_Device->SetRenderState(D3DRS_POINTSIZE, dwPointSize);

	/*m_pGraphic_Device->SetRenderState(D3DRS_POINTSIZE_MIN, m_ParticleAttribute.dwPointSizeMin);
	m_pGraphic_Device->SetRenderState(D3DRS_POINTSIZE_MAX, m_ParticleAttribute.dwPointSizeMax);*/

	m_pGraphic_Device->SetRenderState(D3DRS_POINTSCALE_A, dwPointScaleA);
	m_pGraphic_Device->SetRenderState(D3DRS_POINTSCALE_B, dwPointScaleB);
	m_pGraphic_Device->SetRenderState(D3DRS_POINTSCALE_C, dwPointScaleC);

	return S_OK;
}

HRESULT CParticleSystem::EndRender()
{
	m_pGraphic_Device->SetRenderState(D3DRS_POINTSPRITEENABLE, false);
	m_pGraphic_Device->SetRenderState(D3DRS_POINTSCALEENABLE, false);

	return S_OK;
}

HRESULT CParticleSystem::Create_VertexBuffer()
{
	m_iFVF = D3DFVF_XYZ | D3DFVF_DIFFUSE;

	m_pGraphic_Device->CreateVertexBuffer(
		iParticleCount * sizeof(VTXPARTICLE),
		// 동적 버텍스 버퍼를 이용할 것이며 | 포인트 스프라이트이며 | 이건 잘 모르겠다
		D3DUSAGE_DYNAMIC | D3DUSAGE_POINTS | D3DUSAGE_WRITEONLY,
		m_iFVF,
		// 동적 버텍스 버퍼는 MANAGED에 관리를 못한다고함, 그래서 디폴트줌.
		D3DPOOL_DEFAULT,
		&m_pVB,
		0
	);

	return S_OK;
}

void CParticleSystem::SetParticleAttribute()
{
	for (int i = 0; i < iParticleCount; i++)
	{
		ParticleAttribute att = AddParticle();	
		att.IsAlive = true;

		m_ListParticleAttribute.push_back(att);
	}	
}

DWORD CParticleSystem::GetScale(float f)
{
	return *((DWORD*)&f);
}

float CParticleSystem::GetRandomFloat(float lowBound, float highBound)
{
	// 잘못된 입력 
	if (lowBound >= highBound)
	{
		return lowBound;
	}

	// [0, 1] 범위의 임의의 float 획득.
	float f = (rand() % 10000) * 0.0001f;

	// 최종적으로 lowBound ~ highBound 범위 값 리턴.
	return (f * (highBound - lowBound)) + lowBound;
}

void CParticleSystem::Free()
{
	__super::Free();

	Safe_Release(m_pVB);
	Safe_Release(m_pParticleTexture);
}
